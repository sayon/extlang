#summary What difficulties will you encounter in case you want to push the project further.

= Introduction =

This project was an attempt to introduce some syntax extensions features into Intellij IDEA using a toy language's syntax. The todo list was to implement:
* Interpreting parser. It consumes a .grammar description (as BNF) together with tree transformations descriptions and terminal token representations and parses text files using APIs, provided by Intellij IDEA
* Find usages
* Any code formatter

These goals were accomplished (some partially).

= Parser =

== Descriptions syntax ==
The descriptions support only plain BNF form. Use PsiViewer to see if they were parsed correctly. An example follows:

{{{
--nonterminals:
e
e'
s
s'
t
t'
f
s''
ext
id
elsepart
--starter:
s'
--terminals:
SEMI ";"
LPAR "("
RPAR ")"
WRITE "write"
IF "if"
FI "fi"
LBRACE "{"
RBRACE "}"
PLUS "+"
MUL "*"
MINUS "-"
DIV "/"
WHILE "while"
DO "do"
ELSE "else"
WRITE "write"
READ "read"
ASSIGN ":="
REPEAT "repeat"
UNTIL "until"
SKIP "skip"
NOT "!"
COMPARE "=="
DONE "done"
--rules:
s' ::= s s'' ;
s'' ::= SEMI s' ;
s'' ::= EPSILON ;
s' ::= LBRACE s' RBRACE ;
s ::= SKIP ;
s ::= id ASSIGN e ;
s ::= EPSILON ;
s ::= WHILE e DO s' DONE ;
s ::= IF LPAR e RPAR s elsepart FI;
s ::= WRITE e ;
s ::= READ id;
elsepart ::= ELSE s  ;
elsepart ::= EPSILON ;
e ::= LPAR e RPAR       ;
e ::= NOT e ;
e ::= t e' ;
e' ::= PLUS t e' ;
e' ::= MINUS t e' ;
e' ::= COMPARE t e' ;
e' ::= EPSILON;
t ::= f t';
t' ::= MUL f t' ;
t' ::= DIV f t' ;
t' ::= EPSILON ;
f ::= NUM;
f ::= id;
id ::= IDENT;
s ::= ext ;
ext ::= REPEAT { s' as $action }  UNTIL { e as $condition } -> { < s' ; < $action > < s'' ;< SEMI >< s' ;< s ;< WHILE >< e ;< NOT >< $condition >>< DO >< $action > < DONE >> < s'' >>>>  } ;
}}}

There are following terminal symbols you do not need to enumerate yourself:
* NUM (any number, can be negative, but no space between number and sign is allowed)
* IDENT (identifier)
* EPSILON (empty string)

*NB* you will *always* need to alias IDENT as some kind of nonterminal, and whenever you want to write _IDENT_ in your productions, you will write this nonterminal instead.
In the example above, we aliased IDENT as _id_ and always used _id_ in production rules.

The idea of syntax extensions is well illustrated here: 
http://pauillac.inria.fr/~ddr/camlp5/doc/htmlc/syntext.html#a:An-example-:-repeat--until


==What's so hard in implementing them in IDE? ==

Well,the problem is that syntax extensions mean the AST produced for the compiler is *different* from the one produced during parsing. If we somehow want to produce it anyway we need to come up with some hack. We propose  


== Contacts ==
Should you have any questions, you can email me (igorjirkov)